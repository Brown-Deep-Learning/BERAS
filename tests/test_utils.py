#!/usr/bin/env python3
import sys
import os

"""
DO NOT EDIT THIS FILE!

This file contains the utilities for running and managing tests for BERAS.
The tests allow you to run individual tests, test categories, or all tests at once with clear output and error reporting.
"""

def run_single_test(test_name: str, module_globals: dict, module_name: str = ""):
    available_tests = [name for name in module_globals.keys() if name.startswith('test_') and callable(module_globals[name])]
    
    # First try exact match
    if test_name in module_globals and callable(module_globals[test_name]):
        print(f"Running {test_name}...")
        try:
            module_globals[test_name]()
            print(f"{test_name}: PASSED!")
            return
        except Exception as e:
            print(f"{test_name}: FAILED with error: {e}")
            return
    
    # If no exact match, try fuzzy search
    matching_tests = []
    
    # Look for tests that contain the search term (case insensitive)
    search_term = test_name.lower()
    for test in available_tests:
        if search_term in test.lower():
            matching_tests.append(test)
    
    # If no matches with the full search term, try without "test_" prefix
    if not matching_tests and not search_term.startswith('test_'):
        for test in available_tests:
            # Remove "test_" prefix and check if search term is in the remaining part
            test_without_prefix = test[5:].lower()  # Remove "test_"
            if search_term in test_without_prefix:
                matching_tests.append(test)
    
    if len(matching_tests) == 1:
        # Exactly one match found, run it
        test_to_run = matching_tests[0]
        print(f"Found matching test: {test_to_run}")
        print(f"Running {test_to_run}...")
        try:
            module_globals[test_to_run]()
            print(f"{test_to_run}: PASSED!")
        except Exception as e:
            print(f"{test_to_run}: FAILED with error: {e}")
    elif len(matching_tests) > 1:
        # Multiple matches found
        print(f"Multiple tests found matching '{test_name}':")
        for i, test in enumerate(matching_tests, 1):
            print(f"  {i}. {test}")
        print(f"\nPlease be more specific or run them individually:")
        for test in matching_tests:
            print(f"  python tests/{module_name}.py --test={test}")
    else:
        # No matches found
        print(f"Test '{test_name}' not found!")
        if available_tests:
            print(f"Available tests in {module_name}: {', '.join(available_tests)}")


def list_available_tests(module_globals: dict, module_name: str = ""):
    tests = [name for name in module_globals.keys() if name.startswith('test_') and callable(module_globals[name])]
    
    if module_name:
        print(f"Available tests in {module_name}:")
    else:
        print("Available tests:")
        
    for test in sorted(tests):
        doc = module_globals[test].__doc__ or "No description available"
        # Take only first line/sentence of docstring
        doc = doc.split('\n')[0].strip()
        if doc.endswith('.'):
            doc = doc[:-1]  # Remove trailing period for consistency
        print(f"  {test:<25} - {doc}")
    
    return tests


def run_all_tests(module_globals: dict, module_name: str = ""):
    tests = [name for name in module_globals.keys() if name.startswith('test_') and callable(module_globals[name])]
    passed = 0
    failed = 0
    
    if module_name:
        print(f"Running {len(tests)} tests from {module_name}...\n")
    else:
        print(f"Running {len(tests)} tests...\n")
    
    for test_name in sorted(tests):
        try:
            print(f"Running {test_name}...", end=' ')
            module_globals[test_name]()
            print(f"{test_name}: PASSED!")
            passed += 1
        except Exception as e:
            print(f"{test_name}: FAILED with error: {e}")
            failed += 1
    
    print(f"\nResults: {passed} passed, {failed} failed")
    
    if failed > 0:
        print(f"\nFailed tests:")
        for test_name in sorted(tests):
            try:
                # Don't actually run again, just check if it would fail
                pass
            except:
                pass
    
    return failed == 0


def setup_module_path():
    parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if parent_dir not in sys.path:
        sys.path.insert(0, parent_dir)


def print_test_module_help(module_name: str):
    print("=" * 25 + "TEST FILE USAGE INSTRUCTIONS" + "=" * 25)
    print("To run all of the tests, use the main test runner: python run_tests.py")

    print("Or run tests directly from this file:")
    print(f"  python tests/{module_name}.py --list           # List all tests")
    print(f"  python tests/{module_name}.py --all            # Run all tests")
    print(f"  python tests/{module_name}.py --test=<name>    # Run specific test")


def handle_cli_args(module_globals: dict, module_name: str):

    import sys
    
    if len(sys.argv) > 1:
        command = sys.argv[1]
        if command == "--list":
            list_available_tests(module_globals, module_name)
        elif command == "--all":
            run_all_tests(module_globals, module_name)
        elif command.startswith("--test="):
            test_name = command.split("=")[1]
            run_single_test(test_name, module_globals, module_name)
        else:
            print("Usage:")
            print(f"  python {module_name}.py --list           # List all tests")
            print(f"  python {module_name}.py --all            # Run all tests")
            print(f"  python {module_name}.py --test=<name>    # Run specific test")
    else:
        print_test_module_help(module_name)
